今天复习了C++列表的初始化方式，还是很多记不准的，明天在看一下
- [x] 明天考自己一遍
昨天学习了CMake的相关操作
平时用到最多的操作是：添加新的第三方库的时候要
1. find_package()
2. include_directories()
3. target_link_libraries()
还有SLAM中的数学基础
表达点在直线上：$ax+by+c=[x,y,1][a,b,c]^T=\tilde{p}^Tl=0$
点在平面上：$ax+by+cz+d=[x,y,z,1][a,b,c,1]^T=\tilde{P}^T\pi=0$
已知两点坐标求所在直线：$l=\tilde{p} \times \tilde{q}$
已知两条直线求交点：$\tilde{x} = m \times n$
齐次坐标最后一个元素为0，表达该点为无穷远点
表达变换
${\tilde{p} }'  = \begin{bmatrix} {p}'\\1\end{bmatrix} = \begin{bmatrix} R & t \\  O  & 1\end{bmatrix} \begin{bmatrix} {p}\\1\end{bmatrix}=T \begin{bmatrix} {p}\\1\end{bmatrix}= T{\tilde{p} }$
Eigen库的使用
- 旋转向量
	- 类型：Eigen::AngleAxisd
	- 初始化：Eigen::AngleAxisd rotation_vector(M_PI / 4, Eigen::Vector3d(0, 0, 1));
		- 沿着Eigen::Vector3d(0, 0, 1)轴旋转(M_PI / 4)
	- 属性
		- 旋转轴：.axis()
		- 旋转向量角度：.angle()
	- 转换：
		- 旋转向量转换为旋转矩阵
			- 方法一：
				`rotation_vector.matrix()`
			- 方法二：
				`rotation_vector.toRotationMatrix()`
		- 旋转向量转换为四元数
			`quat.coeffs()`
- 旋转矩阵
	- 类型：Eigen::Matrix3d
	- 初始化：
		- 第一种：Eigen::Matrix3d rotation_matrix = Eigen::Matrix3d::Identity();
		- 第二种：
				```c++
				rotation_matrix << 0.707, -0.707, 0,
			      0.707, 0.707, 0,
			      0, 0, 1;
				```
	- 转换：
		- 旋转矩阵转换为旋转向量
			- 方法一：
				`rotation_vector.fromRotationMatrix(rotation_matrix);`
			- 方法二：
				`rotation_vector = rotation_matrix;`
			- 方法三：
				`rotation_vector = Eigen::AngleAxisd(rotation_matrix);`
		- 旋转矩阵转换为四元数
			- 方法一
				`quat = Eigen::Quaterniond(rotation_matrix);`
			- 方法二
				`quat = rotation_matrix;`
- 四元数
	- 类型：Eigen::Quaterniond
	- 初始化：Eigen::Quaterniond quat = Eigen::Quaterniond(0, 0, 0.383, 0.924);
	- 输出：
		- 方法一：.coeffs()
			// 请注意coeffs的顺序是(x,y,z,w),w为实部，前三者为虚部
		- 方法二： .x()  .y()  .z()  .w() 
	- 转换：
		- 四元数转换为旋转向量
			`rotation_vector = quat;`
		- 四元数转换为旋转矩阵
			- 方法一：
				`rotation_matrix = quat.matrix();`
			- 方法二：
				`rotation_matrix = quat.toRotationMatrix();`
