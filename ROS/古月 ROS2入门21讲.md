## 3 ROS2安装方法
官网安装

## 4 ROS2命令行操作
- 显示隐藏文件
	- `ls -A`
- 递归删除
	- `rm -R test/`
`ros2 run turtlesim turtlesim_node`
	运行turtlesim功能包里面的turtlesim_node功能
`ros2 run turtlesim turtle_teleop_key`
	运行turtlesim功能包里面的turtle_teleop_key功能
`ros2 node`
	查看节点相关信息
`ros2 node list`
	查看ros2中正在运行的所有节点
`ros2 node info /turtlesim`
	查看/turtlesim的信息
`ros2 topic`
	查看话题相关信息
`ros2 topic list`
	查看正在发布和订阅的话题
`ros2 topic echo /turtle1/pose`
	打印/turtle1/pose话题信息
`ros2 topic pub —-rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear:{x:2.0,y:0.0,z:0.0},angular:{x:0.0,y:0.0,z:1.8}}"`
	发布话题数据
	`—-rate 1`：以1hz的频率发布
`ros2 service call /spawn turtlesim/srv/Spawn "{x:2,y:2,theta:0.2,name:''}"`
	产生新海龟
`ros2 bag`
	录制信息
`ros2 bag record /turtle1/cmd_vel`
	录制/turtle1/cmd_vel的数据
	数据默认保持到当前终端所在的路径
`ros2 bag play rosbag2_2022_05_24-16_21_24/`
	复现数据

## 5 ROS2开发环境配置
安装git、vscode
下载课程源码：
```shell
git clone https://gitee.com/guyuehome/ros2_21_tutorials.git
```
vscode插件
- Chinese
- Python√
- C/C++√
- CMake√
- vscode-icons√
- ROS√
- Msg Language Support√
- URDF√
- IntelliCode
- Markdown All in One√

## 6 工作空间与功能包：开发过程的大本营
什么是工作空间？
工作空间（workspace）：是一个存放项目开发相关文件的文件夹；是开发过程的大本营。
ROS2的工作空间结构：
```shell
dev_ws/
	build/    // 编译空间（Build Space）
	install/    // 安装空间（Install Space）
	log/    // 日志空间（Log Space）
	src/    // 代码空间（Source Space）
```

创建工作空间：
```shell
mkdir -p ~/dev_ws/src
cd ~/dev_ws/src
git clone https://gitee.com/guyuehome/ros2_21_tutorials.git
```
自动安装依赖：
```shell
sudo apt install -y python3-pip
sudo pip3 install rosdepc
sudo rosdepc init & rosdepc update
cd ..
rosdepc install -i --from-path src --rosdistro humble -y
```
编译工作空间：
```shell
sudo apt install python3-colcon-ros
cd ~/dev_ws/
colcon build
```
设置环境变量：
```shell
source install/local_setup.sh
echo " source ~/dev_ws/install/local_setup.sh">>~/.bashrc
```
创建功能包
`ros2 pkg create --build-type <build-type> <package_name>`
		`<build-type>`
				c/c++:ament_cmake
				python:ament_python
		`<package_name>`
				功能包的名字
```shell
cd ~/dev_ws/src
ros2 pkg create --build-type ament_cmake learning_pkg_c
ros2 pkg create --build-type ament_python learning_pkg_python
```
那么创建好的C++的功能包里面的结构是怎样的呢？
```shell
learning_pkg_c/
	CMakeLists.txt
	include/
	package.xml
	src/
```
- package.xml：
		主要描述了该功能包的基本信息，比如名字、版本号、功能是什么、维护者、许可证等
		还有描述了该功能包的依赖信息
- CMakeLists.txt:
		设置编译规则
那python的功能包里面的结构又是怎样的呢？
```shell
learning_pkg_python
	learning_pkg_python/
	package.xml
	resource/
	setup.cfg
	setup.py
	test/
```
- package.xml：
		与C++的功能包类似
		主要描述了该功能包的基本信息，比如名字、版本号、功能是什么、维护者、许可证等
		还有描述了该功能包的依赖信息
- setup.cfg：
		基本工作空间的信息配置
- setup.py:
		功能包的基本信息以及入口程序点
编译功能包
```shell
cd ~/dev_ws/src
colcon build
source install/local_setup.bash
```

## 7 节点：机器人的工作细胞
节点的特性：
- 职责是执行具体任务的进程
- 每一个节点都是一个可独立运行的可执行文件
- 可以使用不同的编程语言
- 可分布式运行在不同主机
- 通过节点名称进行管理

创建第一个节点（面向过程编程）
先运行课程已经编写好的代码，查看运行的效果，再自行编写：
```shell
// 进入工作空间
cd ~/dev_ws
// 编译工作空间
colcon build
// 运行helloworld例程
// 运行learning_node功能包里面的node_helloworld节点
ros2 run learning_node node_helloworld
```
下面查看具体的代码实现：
使用vscode打开ROS2_21_TUTORIALS文件夹
打开learning_node功能包里面learning_node同名文件夹下的node_helloworld.py
```python
import rclpy    # ROS2 Python接口类
from rclpy.node import Node    # ROS2 节点类
import time

def main(args=None):    # ROS2节点主入口main函数
	rclpy.init(args=args)    # ROS2 Python接口初始化
	node = Node("node_helloworld")    # 创建ROS2节点对象并进行初始化
	
	while rclpy.ok():    # ROS2系统是否正常运行
		node.get_logger().info("Hello World")    # ROS2日志输出
		time.sleep(0.5)    # 休眠控制循环时间
	
	node.destroy_node()    # 销毁节点对象
	rclpy.shutdown()    # 关闭ROS2 Python接口
```
完成节点的编程之后，为了能通过ros2 run命令来运行，还需要在功能包里面进行程序入口的配置，该配置只针对python版本的ros2程序
配置文件在learning_node功能包里面的setup.py文件
```python
setup(
	  entry_points={
		  'console_scripts':[
			  'node_helloworld = learning_node.node_helloworld:main'
		  ]
	  }
)
```
配置完成之后，就可以在工作空间里面进行编译，并通过ros2 run进行运行了
总结一下节点的编程流程如下：
- 编程接口初始化
- 创建节点并初始化
- 实现节点功能
- 销毁节点并关闭接口
上述代码使用的是面向过程的编程方式，下面将使用面向对象编程的方式来对代码进行优化：
`node_helloworld_class.py`
运行节点：
```shell
ros2 run learning_node node_helloworld_class
```
```python
import rclpy    # ROS2 Python接口类
from rclpy.node import Node    # ROS2 节点类
import time

"""
创建一个HelloWorld节点，初始化时输出"hello world"日志
"""
class HelloWorldNode(Node):
	def __init__(self,name):
		super().__init__(name)    # ROS2节点父类初始化
		while rclpy.ok():    # ROS2系统是否正常运行
			self.get_logger().info("Hello World")    # ROS2日志输出
			time.sleep(0.5)    # 休眠控制循环时间


def main(args=None):    # ROS2节点主入口main函数
	rclpy.init(args=args)    # ROS2 Python接口初始化
	node = HelloWorldNode("node_helloworld_class")    # 创建ROS2节点对象比进行初始化
	node.destroy_node()    # 销毁节点对象
	rclpy.shutdown()    # 关闭ROS2 Python接口
```
一样，也需要配置setup.py的程序入口
编译成功之后的执行文件所在的目录为`~/dev_ws/install/learning_node/lib/learning_node/`

下面执行一个更加复杂的程序：识别图片中的苹果
运行节点：
```shell
sudo apt install python3-opencv
ros2 run learning_node node_object # 注意修改图片路径后重新编译
```
具体代码如下：
```python
import rclpy                            # ROS2 Python接口库
from rclpy.node import Node             # ROS2 节点类

import cv2                              # OpenCV图像处理库
import numpy as np                      # Python数值计算库

lower_red = np.array([0, 90, 128])     # 红色的HSV阈值下限
upper_red = np.array([180, 255, 255])  # 红色的HSV阈值上限

def object_detect(image):
    hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)      # 图像从BGR颜色模型转换为HSV模型
    mask_red = cv2.inRange(hsv_img, lower_red, upper_red) # 图像二值化

    contours, hierarchy = cv2.findContours(mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) # 图像中轮廓检测

    for cnt in contours:                                  # 去除一些轮廓面积太小的噪声
        if cnt.shape[0] < 150:
            continue

        (x, y, w, h) = cv2.boundingRect(cnt)              # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高
        cv2.drawContours(image, [cnt], -1, (0, 255, 0), 2)# 将苹果的轮廓勾勒出来
        cv2.circle(image, (int(x+w/2), int(y+h/2)), 5, (0, 255, 0), -1)# 将苹果的图像中心点画出来

    cv2.imshow("object", image)                           # 使用OpenCV显示处理后的图像效果
    cv2.waitKey(0)
    cv2.destroyAllWindows()

def main(args=None):                                      # ROS2节点主入口main函数
    rclpy.init(args=args)                                 # ROS2 Python接口初始化
    node = Node("node_object")                            # 创建ROS2节点对象并进行初始化
    node.get_logger().info("ROS2节点示例：检测图片中的苹果")

    image = cv2.imread('/home/hcx/dev_ws/src/ros2_21_tutorials/learning_node/learning_node/apple.jpg')  # 读取图像
    object_detect(image)                                   # 苹果检测
    rclpy.spin(node)                                       # 循环等待ROS2退出
    node.destroy_node()                                    # 销毁节点对象
    rclpy.shutdown()                                       # 关闭ROS2 Python接口
```

下面我们让机器人调用摄像头去动态识别
```shell
ros2 run learning_node node_object_webcam # 注意设置摄像头
```
具体的代码如下：
```python
import rclpy                            # ROS2 Python接口库
from rclpy.node import Node             # ROS2 节点类

import cv2                              # OpenCV图像处理库
import numpy as np                      # Python数值计算库

lower_red = np.array([0, 90, 128])     # 红色的HSV阈值下限
upper_red = np.array([180, 255, 255])  # 红色的HSV阈值上限

def object_detect(image):
    hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)       # 图像从BGR颜色模型转换为HSV模型
    mask_red = cv2.inRange(hsv_img, lower_red, upper_red)  # 图像二值化

    contours, hierarchy = cv2.findContours(mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) # 图像中轮廓检测

    for cnt in contours:                                   # 去除一些轮廓面积太小的噪声
        if cnt.shape[0] < 150:
            continue

        (x, y, w, h) = cv2.boundingRect(cnt)               # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高
        cv2.drawContours(image, [cnt], -1, (0, 255, 0), 2) # 将苹果的轮廓勾勒出来
        cv2.circle(image, (int(x+w/2), int(y+h/2)), 5, (0, 255, 0), -1)    # 将苹果的图像中心点画出来

    cv2.imshow("object", image)                            # 使用OpenCV显示处理后的图像效果
    cv2.waitKey(50)

def main(args=None):                                       # ROS2节点主入口main函数
    rclpy.init(args=args)                                  # ROS2 Python接口初始化
    node = Node("node_object_webcam")                      # 创建ROS2节点对象并进行初始化
    node.get_logger().info("ROS2节点示例：检测图片中的苹果")

    cap = cv2.VideoCapture(0)


    while rclpy.ok():
        ret, image = cap.read()          # 读取一帧图像

        if ret == True:
            object_detect(image)         # 苹果检测

    node.destroy_node()                  # 销毁节点对象
    rclpy.shutdown()                     # 关闭ROS2 Python接口
```

## 8 话题：节点间传递数据的桥梁

- 话题使用了发布/订阅模型
- 订阅者或发布者可以不唯一
- 异步通信机制
- .msg文件定义通信的消息结构
