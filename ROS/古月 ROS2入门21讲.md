## 3 ROS2安装方法
官网安装

## 4 ROS2命令行操作
- 显示隐藏文件
	- `ls -A`
- 递归删除
	- `rm -R test/`
`ros2 run turtlesim turtlesim_node`
	运行turtlesim功能包里面的turtlesim_node功能
`ros2 run turtlesim turtle_teleop_key`
	运行turtlesim功能包里面的turtle_teleop_key功能
`ros2 node`
	查看节点相关信息
`ros2 node list`
	查看ros2中正在运行的所有节点
`ros2 node info /turtlesim`
	查看/turtlesim的信息
`ros2 topic`
	查看话题相关信息
`ros2 topic list`
	查看正在发布和订阅的话题
`ros2 topic echo /turtle1/pose`
	打印/turtle1/pose话题信息
`ros2 topic pub —-rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear:{x:2.0,y:0.0,z:0.0},angular:{x:0.0,y:0.0,z:1.8}}"`
	发布话题数据
	`—-rate 1`：以1hz的频率发布
`ros2 service call /spawn turtlesim/srv/Spawn "{x:2,y:2,theta:0.2,name:''}"`
	产生新海龟
`ros2 bag`
	录制信息
`ros2 bag record /turtle1/cmd_vel`
	录制/turtle1/cmd_vel的数据
	数据默认保持到当前终端所在的路径
`ros2 bag play rosbag2_2022_05_24-16_21_24/`
	复现数据

## 5 ROS2开发环境配置
安装git、vscode
下载课程源码：
```shell
git clone https://gitee.com/guyuehome/ros2_21_tutorials.git
```
vscode插件
- Chinese
- Python√
- C/C++√
- CMake√
- vscode-icons√
- ROS√
- Msg Language Support√
- URDF√
- IntelliCode
- Markdown All in One√

## 6 工作空间与功能包：开发过程的大本营
什么是工作空间？
工作空间（workspace）：是一个存放项目开发相关文件的文件夹；是开发过程的大本营。
ROS2的工作空间结构：
```shell
dev_ws/
	build/    // 编译空间（Build Space）
	install/    // 安装空间（Install Space）
	log/    // 日志空间（Log Space）
	src/    // 代码空间（Source Space）
```

创建工作空间：
```shell
mkdir -p ~/dev_ws/src
cd ~/dev_ws/src
git clone https://gitee.com/guyuehome/ros2_21_tutorials.git
```
自动安装依赖：
```shell
sudo apt install -y python3-pip
sudo pip3 install rosdepc
sudo rosdepc init & rosdepc update
cd ..
rosdepc install -i --from-path src --rosdistro humble -y
```
编译工作空间：
```shell
sudo apt install python3-colcon-ros
cd ~/dev_ws/
colcon build
```
设置环境变量：
```shell
source install/local_setup.sh
echo " source ~/dev_ws/install/local_setup.sh">>~/.bashrc
```
创建功能包
`ros2 pkg create --build-type <build-type> <package_name>`
		`<build-type>`
				c/c++:ament_cmake
				python:ament_python
		`<package_name>`
				功能包的名字
```shell
cd ~/dev_ws/src
ros2 pkg create --build-type ament_cmake learning_pkg_c
ros2 pkg create --build-type ament_python learning_pkg_python
```
那么创建好的C++的功能包里面的结构是怎样的呢？
```shell
learning_pkg_c/
	CMakeLists.txt
	include/
	package.xml
	src/
```
- package.xml：
		主要描述了该功能包的基本信息，比如名字、版本号、功能是什么、维护者、许可证等
		还有描述了该功能包的依赖信息
- CMakeLists.txt:
		设置编译规则
那python的功能包里面的结构又是怎样的呢？
```shell
learning_pkg_python
	learning_pkg_python/
	package.xml
	resource/
	setup.cfg
	setup.py
	test/
```
- package.xml：
		与C++的功能包类似
		主要描述了该功能包的基本信息，比如名字、版本号、功能是什么、维护者、许可证等
		还有描述了该功能包的依赖信息
- setup.cfg：
		基本工作空间的信息配置
- setup.py:
		功能包的基本信息以及入口程序点
编译功能包
```shell
cd ~/dev_ws/src
colcon build
source install/local_setup.bash
```

## 7 节点：机器人的工作细胞
节点的特性：
- 职责是执行具体任务的进程
- 每一个节点都是一个可独立运行的可执行文件
- 可以使用不同的编程语言
- 可分布式运行在不同主机
- 通过节点名称进行管理

创建第一个节点（面向过程编程）
先运行课程已经编写好的代码，查看运行的效果，再自行编写：
```shell
// 进入工作空间
cd ~/dev_ws
// 编译工作空间
colcon build
// 运行helloworld例程
// 运行learning_node功能包里面的node_helloworld节点
ros2 run learning_node node_helloworld
```
下面查看具体的代码实现：
使用vscode打开ROS2_21_TUTORIALS文件夹
打开learning_node功能包里面learning_node同名文件夹下的node_helloworld.py
```python
import rclpy    # ROS2 Python接口类
from rclpy.node import Node    # ROS2 节点类
import time

def main(args=None):    # ROS2节点主入口main函数
	rclpy.init(args=args)    # ROS2 Python接口初始化
	node = Node("node_helloworld")    # 创建ROS2节点对象并进行初始化
	
	while rclpy.ok():    # ROS2系统是否正常运行
		node.get_logger().info("Hello World")    # ROS2日志输出
		time.sleep(0.5)    # 休眠控制循环时间
	
	node.destroy_node()    # 销毁节点对象
	rclpy.shutdown()    # 关闭ROS2 Python接口
```
完成节点的编程之后，为了能通过ros2 run命令来运行，还需要在功能包里面进行程序入口的配置，该配置只针对python版本的ros2程序
配置文件在learning_node功能包里面的setup.py文件
```python
setup(
	  entry_points={
		  'console_scripts':[
			  'node_helloworld = learning_node.node_helloworld:main'
		  ]
	  }
)
```
配置完成之后，就可以在工作空间里面进行编译，并通过ros2 run进行运行了
总结一下节点的编程流程如下：
- 编程接口初始化
- 创建节点并初始化
- 实现节点功能
- 销毁节点并关闭接口
上述代码使用的是面向过程的编程方式，下面将使用面向对象编程的方式来对代码进行优化：
`node_helloworld_class.py`
运行节点：
```shell
ros2 run learning_node node_helloworld_class
```
```python
import rclpy    # ROS2 Python接口类
from rclpy.node import Node    # ROS2 节点类
import time

"""
创建一个HelloWorld节点，初始化时输出"hello world"日志
"""
class HelloWorldNode(Node):
	def __init__(self,name):
		super().__init__(name)    # ROS2节点父类初始化
		while rclpy.ok():    # ROS2系统是否正常运行
			self.get_logger().info("Hello World")    # ROS2日志输出
			time.sleep(0.5)    # 休眠控制循环时间


def main(args=None):    # ROS2节点主入口main函数
	rclpy.init(args=args)    # ROS2 Python接口初始化
	node = HelloWorldNode("node_helloworld_class")    # 创建ROS2节点对象比进行初始化
	node.destroy_node()    # 销毁节点对象
	rclpy.shutdown()    # 关闭ROS2 Python接口
```
一样，也需要配置setup.py的程序入口
编译成功之后的执行文件所在的目录为`~/dev_ws/install/learning_node/lib/learning_node/`

下面执行一个更加复杂的程序：识别图片中的苹果
运行节点：
```shell
sudo apt install python3-opencv
ros2 run learning_node node_object # 注意修改图片路径后重新编译
```
具体代码如下：
```python
import rclpy                            # ROS2 Python接口库
from rclpy.node import Node             # ROS2 节点类

import cv2                              # OpenCV图像处理库
import numpy as np                      # Python数值计算库

lower_red = np.array([0, 90, 128])     # 红色的HSV阈值下限
upper_red = np.array([180, 255, 255])  # 红色的HSV阈值上限

def object_detect(image):
    hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)      # 图像从BGR颜色模型转换为HSV模型
    mask_red = cv2.inRange(hsv_img, lower_red, upper_red) # 图像二值化

    contours, hierarchy = cv2.findContours(mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) # 图像中轮廓检测

    for cnt in contours:                                  # 去除一些轮廓面积太小的噪声
        if cnt.shape[0] < 150:
            continue

        (x, y, w, h) = cv2.boundingRect(cnt)              # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高
        cv2.drawContours(image, [cnt], -1, (0, 255, 0), 2)# 将苹果的轮廓勾勒出来
        cv2.circle(image, (int(x+w/2), int(y+h/2)), 5, (0, 255, 0), -1)# 将苹果的图像中心点画出来

    cv2.imshow("object", image)                           # 使用OpenCV显示处理后的图像效果
    cv2.waitKey(0)
    cv2.destroyAllWindows()

def main(args=None):                                      # ROS2节点主入口main函数
    rclpy.init(args=args)                                 # ROS2 Python接口初始化
    node = Node("node_object")                            # 创建ROS2节点对象并进行初始化
    node.get_logger().info("ROS2节点示例：检测图片中的苹果")

    image = cv2.imread('/home/hcx/dev_ws/src/ros2_21_tutorials/learning_node/learning_node/apple.jpg')  # 读取图像
    object_detect(image)                                   # 苹果检测
    rclpy.spin(node)                                       # 循环等待ROS2退出
    node.destroy_node()                                    # 销毁节点对象
    rclpy.shutdown()                                       # 关闭ROS2 Python接口
```

下面我们让机器人调用摄像头去动态识别
```shell
ros2 run learning_node node_object_webcam # 注意设置摄像头
```
具体的代码如下：
```python
import rclpy                            # ROS2 Python接口库
from rclpy.node import Node             # ROS2 节点类

import cv2                              # OpenCV图像处理库
import numpy as np                      # Python数值计算库

lower_red = np.array([0, 90, 128])     # 红色的HSV阈值下限
upper_red = np.array([180, 255, 255])  # 红色的HSV阈值上限

def object_detect(image):
    hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)       # 图像从BGR颜色模型转换为HSV模型
    mask_red = cv2.inRange(hsv_img, lower_red, upper_red)  # 图像二值化

    contours, hierarchy = cv2.findContours(mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) # 图像中轮廓检测

    for cnt in contours:                                   # 去除一些轮廓面积太小的噪声
        if cnt.shape[0] < 150:
            continue

        (x, y, w, h) = cv2.boundingRect(cnt)               # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高
        cv2.drawContours(image, [cnt], -1, (0, 255, 0), 2) # 将苹果的轮廓勾勒出来
        cv2.circle(image, (int(x+w/2), int(y+h/2)), 5, (0, 255, 0), -1)    # 将苹果的图像中心点画出来

    cv2.imshow("object", image)                            # 使用OpenCV显示处理后的图像效果
    cv2.waitKey(50)

def main(args=None):                                       # ROS2节点主入口main函数
    rclpy.init(args=args)                                  # ROS2 Python接口初始化
    node = Node("node_object_webcam")                      # 创建ROS2节点对象并进行初始化
    node.get_logger().info("ROS2节点示例：检测图片中的苹果")

    cap = cv2.VideoCapture(0)


    while rclpy.ok():
        ret, image = cap.read()          # 读取一帧图像

        if ret == True:
            object_detect(image)         # 苹果检测

    node.destroy_node()                  # 销毁节点对象
    rclpy.shutdown()                     # 关闭ROS2 Python接口
```

## 8 话题：节点间传递数据的桥梁

- 话题使用了发布/订阅模型
- 订阅者或发布者可以不唯一
- 异步通信机制
- .msg文件定义通信的消息结构
那么如何实现一个简单的话题通信呢？
我们创建一个发布者Publisher，发布话题chatter，周期发送Hello World字符串，消息类型是ros中标准定义的String类型，再创建一个订阅者Subscirber，订阅chatter这个话题，从而接收到字符串。
我们先来运行看一下效果
```shell
ros2 run learning_topic topic_helloworld_pub
```
再启动一个新的终端，来运行订阅者节点
```shell
ros2 run learning_topic topic_hellowowrld_sub
```
下面看一下代码的具体实现
先看发布者：topic_helloworld_pub
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
@作者: 古月居(www.guyuehome.com)
@说明: ROS2话题示例-发布“Hello World”话题
"""

import rclpy                                     # ROS2 Python接口库
from rclpy.node import Node                      # ROS2 节点类
from std_msgs.msg import String                  # 字符串消息类型

"""
创建一个发布者节点
"""
class PublisherNode(Node):
    
    def __init__(self, name):
        super().__init__(name)                                    # ROS2节点父类初始化
        self.pub = self.create_publisher(String, "chatter", 10)   # 创建发布者对象（消息类型、话题名、队列长度）
        self.timer = self.create_timer(0.5, self.timer_callback)  # 创建一个定时器（单位为秒的周期，定时执行的回调函数）
        
    def timer_callback(self):                                     # 创建定时器周期执行的回调函数
        msg = String()                                            # 创建一个String类型的消息对象
        msg.data = 'Hello World'                                  # 填充消息对象中的消息数据
        self.pub.publish(msg)                                     # 发布话题消息
        self.get_logger().info('Publishing: "%s"' % msg.data)     # 输出日志信息，提示已经完成话题发布
        
def main(args=None):                                 # ROS2节点主入口main函数
    rclpy.init(args=args)                            # ROS2 Python接口初始化
    node = PublisherNode("topic_helloworld_pub")     # 创建ROS2节点对象并进行初始化
    rclpy.spin(node)                                 # 循环等待ROS2退出
    node.destroy_node()                              # 销毁节点对象
    rclpy.shutdown()                                 # 关闭ROS2 Python接口
```
再看订阅者topic_hellowowrld_sub
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
@作者: 古月居(www.guyuehome.com)
@说明: ROS2话题示例-订阅“Hello World”话题消息
"""

import rclpy                                     # ROS2 Python接口库
from rclpy.node   import Node                    # ROS2 节点类
from std_msgs.msg import String                  # ROS2标准定义的String消息

"""
创建一个订阅者节点
"""
class SubscriberNode(Node):
    
    def __init__(self, name):
        super().__init__(name)                                    # ROS2节点父类初始化
        self.sub = self.create_subscription(\
            String, "chatter", self.listener_callback, 10)        # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度）

    def listener_callback(self, msg):                             # 创建回调函数，执行收到话题消息后对数据的处理
        self.get_logger().info('I heard: "%s"' % msg.data)        # 输出日志信息，提示订阅收到的话题消息
        
def main(args=None):                                 # ROS2节点主入口main函数
    rclpy.init(args=args)                            # ROS2 Python接口初始化
    node = SubscriberNode("topic_helloworld_sub")    # 创建ROS2节点对象并进行初始化
    rclpy.spin(node)                                 # 循环等待ROS2退出
    node.destroy_node()                              # 销毁节点对象
    rclpy.shutdown()                                 # 关闭ROS2 Python接口

```
当然也不要忘记再setup.py里面对整个程序入口进行配置，这样编译之后才能通过ros2 run命令运行节点。
下面总结一下创建话题发布者的程序流程：
- 编程接口初始化
- 创建节点并初始化
- 创建发布者对象
- 创建并填充话题消息
- 发布话题消息
- 销毁节点并关闭接口
要创建话题订阅者的流程如下：
- 编程接口初始化
- 创建节点并初始化
- 创建订阅者对象
- 回调函数处理话题数据
- 销毁节点并关闭接口
	
下面我们实现一个更为复杂的话题通信，我们基于话题通信继续优化一下之前的机器视觉的历程，在节点概念的讲解中，我们通过一个节点驱动了相机，并实现了对红色物体的识别，但对于机器人开发来讲，并没有做到程序的模块化，更好的方式是将相机驱动跟视觉识别做成两个节点，节点间的联系就是通过话题来做周期的传输，这个图像消息的类型是Image，是在raw当中标准定义好的，如果未来想要更换另一个相机硬件，只需要去修改你的驱动节点，视觉识别节点是完全可以保持不变的，这种模块化的设计思想可以更好的保证软件的可移植性
我们先来看一下效果如何
运动第一个节点驱动相机，并发布相机的数据
```shell
ros2 run learning_topic topic_webcam_pub
```
再来运行第二个节点
```shell
ros2 run learning_topic topic_webcam_sub
```
在看一下具体的代码实现
topic_webcam_pub
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
@作者: 古月居(www.guyuehome.com)
@说明: ROS2话题示例-发布图像话题
"""

import rclpy                        # ROS2 Python接口库
from rclpy.node import Node         # ROS2 节点类
from sensor_msgs.msg import Image   # 图像消息类型
from cv_bridge import CvBridge      # ROS与OpenCV图像转换类
import cv2                          # Opencv图像处理库

"""
创建一个发布者节点
"""
class ImagePublisher(Node):

    def __init__(self, name):
        super().__init__(name)                                           # ROS2节点父类初始化
        self.publisher_ = self.create_publisher(Image, 'image_raw', 10)  # 创建发布者对象（消息类型、话题名、队列长度）
        self.timer = self.create_timer(0.1, self.timer_callback)         # 创建一个定时器（单位为秒的周期，定时执行的回调函数）
        self.cap = cv2.VideoCapture(0)                                   # 创建一个视频采集对象，驱动相机采集图像（相机设备号）
        self.cv_bridge = CvBridge()                                      # 创建一个图像转换对象，用于稍后将OpenCV的图像转换成ROS的图像消息

    def timer_callback(self):
        ret, frame = self.cap.read()                                     # 一帧一帧读取图像
        
        if ret == True:                                                  # 如果图像读取成功
            self.publisher_.publish(
                self.cv_bridge.cv2_to_imgmsg(frame, 'bgr8'))             # 发布图像消息

        self.get_logger().info('Publishing video frame')                 # 输出日志信息，提示已经完成图像话题发布

def main(args=None):                                 # ROS2节点主入口main函数
    rclpy.init(args=args)                            # ROS2 Python接口初始化
    node = ImagePublisher("topic_webcam_pub")        # 创建ROS2节点对象并进行初始化
    rclpy.spin(node)                                 # 循环等待ROS2退出
    node.destroy_node()                              # 销毁节点对象
    rclpy.shutdown()                                 # 关闭ROS2 Python接口

```
以下是订阅者的实现
topic_webcam_sub
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
@作者: 古月居(www.guyuehome.com)
@说明: ROS2话题示例-订阅图像话题
"""

import rclpy                            # ROS2 Python接口库
from rclpy.node import Node             # ROS2 节点类
from sensor_msgs.msg import Image       # 图像消息类型
from cv_bridge import CvBridge          # ROS与OpenCV图像转换类
import cv2                              # Opencv图像处理库
import numpy as np                      # Python数值计算库

lower_red = np.array([0, 90, 128])      # 红色的HSV阈值下限
upper_red = np.array([180, 255, 255])   # 红色的HSV阈值上限

"""
创建一个订阅者节点
"""
class ImageSubscriber(Node):
    def __init__(self, name):
        super().__init__(name)                                  # ROS2节点父类初始化
        self.sub = self.create_subscription(
            Image, 'image_raw', self.listener_callback, 10)     # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度）
        self.cv_bridge = CvBridge()                             # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换

    def object_detect(self, image):
        hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)        # 图像从BGR颜色模型转换为HSV模型
        mask_red = cv2.inRange(hsv_img, lower_red, upper_red)   # 图像二值化
        contours, hierarchy = cv2.findContours(
            mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)     # 图像中轮廓检测

        for cnt in contours:                                    # 去除一些轮廓面积太小的噪声
            if cnt.shape[0] < 150:
                continue

            (x, y, w, h) = cv2.boundingRect(cnt)                # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高
            cv2.drawContours(image, [cnt], -1, (0, 255, 0), 2)  # 将苹果的轮廓勾勒出来
            cv2.circle(image, (int(x+w/2), int(y+h/2)), 5,
                       (0, 255, 0), -1)                         # 将苹果的图像中心点画出来

        cv2.imshow("object", image)                             # 使用OpenCV显示处理后的图像效果
        cv2.waitKey(10)

    def listener_callback(self, data):
        self.get_logger().info('Receiving video frame')         # 输出日志信息，提示已进入回调函数
        image = self.cv_bridge.imgmsg_to_cv2(data, 'bgr8')      # 将ROS的图像消息转化成OpenCV图像
        self.object_detect(image)                               # 苹果检测


def main(args=None):                                        # ROS2节点主入口main函数
    rclpy.init(args=args)                                   # ROS2 Python接口初始化
    node = ImageSubscriber("topic_webcam_sub")              # 创建ROS2节点对象并进行初始化
    rclpy.spin(node)                                        # 循环等待ROS2退出
    node.destroy_node()                                     # 销毁节点对象
    rclpy.shutdown()                                        # 关闭ROS2 Python接口

```
通过话题对原本节点功能的解耦，似乎让视觉识别历程焕然一新了，不过似乎还有点不太对劲，ros的目标不是提高软件的复用率吗？现在视觉识别功能可以去复用了，相机驱动节点好像还不行啊，每换一个相机是不是都得去换一个驱动节点呢？这当然是不可能的，常用的usb相机驱动一般都是通用的，ros当然也集成了usb相机的标准驱动，我们可以通过以下指令就可以安装好
```shell
sudo apt install ros-humble-usb-cam
```
无论你使用什么相机，只要符合usb接口的协议，就可以直接使用ros里面的相机驱动节点来发布标准的图像话题了，这样我们的代码又得到了进一步的精简，我们来试一试
安装驱动之后，就可以运行了
```shell
ros2 run usb_cam usb_cam_node_exe
```
再运行订阅者节点
```shell
ros2 run learning_topic topic_webcam_sub
```
可以通过以下命令对话题进行查看
```shell
ros2 topic
```
- list：查看正在发布和订阅的话题
- info /image_raw：查看话题的更多信息
- bw /image_raw：查看话题的带宽
- echo /image_raw：查看话题里面的详细数据
如果想知道整个系统里面的节点的结构可以使用
```shell
rqt_graph
```

## 9 服务：节点间的你问我答
话题通信可以实现多个ROS节点之间数据的单向传输，使用这种异步通信机制，发布者无法准确知道订阅者是否收到消息，本节课我们将一起学习ROS另外一种常用的通信方法——服务，可以实现类似你问我答的同步通信效果
### 通信模型
在之前的课程中，我们通过一个节点驱动相机，发布图像话题，另外一个节点订阅图像话题，并实现对其中红色物体的识别，此时我们可以按照图像识别的频率，周期得到物体的位置。
![](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.5_%E6%9C%8D%E5%8A%A1/image-20220527232959464.png)
这个位置信息可以继续发给机器人的上层应用使用，比如可以跟踪目标运动，或者运动到目标位置附近。此时，我们并不需要这么高的频率一直订阅物体的位置，而是希望在需要这个数据的时候，发一个查询的请求，然后尽快得到此时目标的最新位置。

这样的通信模型和话题单向传输有所不同，变成了发送一个请求，反馈一个应答的形式，好像是你问我答一样，这种通信机制在ROS中称为服务，Service

### 客户端/服务器模型
从服务的实现机制上来看，这种你问我答的形式叫做客户端/服务器模型，简称为CS模型，客户端在需要某些数据的时候，针对某个具体的服务，发送请求信息，服务器端收到请求之后，就会进行处理并反馈应答信息。
![](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.5_%E6%9C%8D%E5%8A%A1/image8.gif)
这种通信机制在生活中也很常见，比如我们经常浏览的各种网页，此时你的电脑浏览器就是客户端，通过域名或者各种操作，向网站服务器发送请求，服务器收到之后返回需要展现的页面数据。

### 同步通信
这个过程一般要求越快越好，假设服务器半天没有反应，你的浏览器一直转圈圈，那有可能是服务器宕机了，或者是网络不好，所以相比话题通信，在服务通信中，客户端可以通过收到的应答信息，判断服务器端的状态，我们也称之为同步通信。

### 一对多通信
![](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.5_%E6%9C%8D%E5%8A%A1/image9.gif)
比如古月居这个网站，服务器是唯一存在的，并没有多个完全一样的古月居网站，但是可以访问古月居网站的客户端是不唯一的，大家每一个人都可以看到同样的界面。所以服务通信模型中，服务器端唯一，但是客户端可以不唯一。

### 服务接口
和话题通信类似，服务通信的核心还是要传递数据，数据变成了两个部分，一个请求的数据，比如请求苹果位置的命令，还有一个反馈的数据，比如反馈苹果坐标系位置的数据，这些数据和话题消息一样，在ROS中也是要标准定义的，话题使用.msg文件定义，服务使用的是.srv文件定义的，后续我们会给大家介绍定义的方法。

### 案例一：加法求解器
大家现在对ROS服务通信应该有了基本了解，接下来我们就要开始编写代码了，还是从一个相对简单的例程开始，也是ROS官方的一个例程，通过服务实现一个加法求解器的功能。
![](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.5_%E6%9C%8D%E5%8A%A1/image-20220527233716400.png)
当我们需要计算两个加数的求和结果时，就通过客户端节点，将两个加数封装成请求数据，针对服务"add_two_ints"发送出去，提供这个服务的服务端节点，收到请求数据后，开始进行加法计算，并将求和结果封装成应答数据，反馈给客户端，之后客户端就可以得到想要的结果了。

#### 运行效果
我们一起操作下这个例程，并且看下代码的实现原理。

启动两个终端，并运行如下节点，第一个节点是服务端，等待请求数据并提供求和功能，第二个节点是客户端，发送传入的两个加数并等待求和结果。
```shell
ros2 run learning_service service_adder_server
ros2 run learning_service service_adder_client 2 3
```
![](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.5_%E6%9C%8D%E5%8A%A1/image-20220527233928009.png)

![](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.5_%E6%9C%8D%E5%8A%A1/image-20220527233916665.png)

#### 客户端代码解析
我们来看下客户端的实现方法。
程序实现
learning_service/service_adder_client.py
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
@作者: 古月居(www.guyuehome.com)
@说明: ROS2服务示例-发送两个加数，请求加法器计算
"""

import sys

import rclpy                                  # ROS2 Python接口库
from rclpy.node   import Node                 # ROS2 节点类
from learning_interface.srv import AddTwoInts # 自定义的服务接口

class adderClient(Node):
    def __init__(self, name):
        super().__init__(name)                                       # ROS2节点父类初始化
        self.client = self.create_client(AddTwoInts, 'add_two_ints') # 创建服务客户端对象（服务接口类型，服务名）
        while not self.client.wait_for_service(timeout_sec=1.0):     # 循环等待服务器端成功启动
            self.get_logger().info('service not available, waiting again...') 
        self.request = AddTwoInts.Request()                          # 创建服务请求的数据对象

    def send_request(self):                                          # 创建一个发送服务请求的函数
        self.request.a = int(sys.argv[1])
        self.request.b = int(sys.argv[2])
        self.future = self.client.call_async(self.request)           # 异步方式发送服务请求

def main(args=None):
    rclpy.init(args=args)                        # ROS2 Python接口初始化
    node = adderClient("service_adder_client")   # 创建ROS2节点对象并进行初始化
    node.send_request()                          # 发送服务请求

    while rclpy.ok():                            # ROS2系统正常运行
        rclpy.spin_once(node)                    # 循环执行一次节点

        if node.future.done():                   # 数据是否处理完成
            try:
                response = node.future.result()  # 接收服务器端的反馈数据
            except Exception as e:
                node.get_logger().info(
                    'Service call failed %r' % (e,))
            else:
                node.get_logger().info(          # 将收到的反馈信息打印输出
                    'Result of add_two_ints: for %d + %d = %d' % 
                    (node.request.a, node.request.b, response.sum))
            break

    node.destroy_node()                          # 销毁节点对象
    rclpy.shutdown()                             # 关闭ROS2 Python接口

```
完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置：
```json
    entry_points={
        'console_scripts': [
         'service_adder_client  = learning_service.service_adder_client:main',
        ],
    },

```
流程总结
对以上程序进行分析，如果我们想要实现一个客户端，流程如下：
- 编程接口初始化
- 创建节点并初始化
- 创建客户端对象
- 创建并发送请求数据
- 等待服务器端应答数据
- 销毁节点并关闭接口
### 服务端代码解析

至于服务器端的实现，有点类似话题通信中的订阅者，并不知道请求数据什么时间出现，也用到了回调函数机制。

程序实现
learning_service/service_adder_server.py
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
@作者: 古月居(www.guyuehome.com)
@说明: ROS2服务示例-提供加法器的服务器处理功能
"""

import rclpy                                     # ROS2 Python接口库
from rclpy.node   import Node                    # ROS2 节点类
from learning_interface.srv import AddTwoInts    # 自定义的服务接口

class adderServer(Node):
    def __init__(self, name):
        super().__init__(name)                                                           # ROS2节点父类初始化
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.adder_callback)  # 创建服务器对象（接口类型、服务名、服务器回调函数）

    def adder_callback(self, request, response):   # 创建回调函数，执行收到请求后对数据的处理
        response.sum = request.a + request.b       # 完成加法求和计算，将结果放到反馈的数据中
        self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))   # 输出日志信息，提示已经完成加法求和计算
        return response                          # 反馈应答信息

def main(args=None):                             # ROS2节点主入口main函数
    rclpy.init(args=args)                        # ROS2 Python接口初始化
    node = adderServer("service_adder_server")   # 创建ROS2节点对象并进行初始化
    rclpy.spin(node)                             # 循环等待ROS2退出
    node.destroy_node()                          # 销毁节点对象
    rclpy.shutdown()                             # 关闭ROS2 Python接口

```
完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置：
```json
    entry_points={
        'console_scripts': [
         'service_adder_client  = learning_service.service_adder_client:main',
         'service_adder_server  = learning_service.service_adder_server:main',
        ],
    },

```

流程总结
对以上程序进行分析，如果我们想要实现一个服务端，流程如下：
- 编程接口初始化
- 创建节点并初始化
- 创建服务器端对象
- 通过回调函数处进行服务
- 向客户端反馈应答结果
- 销毁节点并关闭接口

### 案例二：机器视觉识别
好啦，加法求解器已经实现了，回想下刚才我们提到的视觉识别流程，当我们需要知道目标物体位置的时候，通过服务通信的机制，岂不是更加合理。
![](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.5_%E6%9C%8D%E5%8A%A1/image-20220527235027462.png)

运行效果

此时会有三个节点出现：

1. 相机驱动节点，发布图像数据；
2. 视觉识别节点，订阅图像数据，并且集成了一个服务器端对象，随时准备提供目标位置；
3. 客户端节点，我们可以认为是一个机器人目标跟踪的节点，当需要跟踪目标运动时，就发送一次请求，然后拿到一个当前的目标位置。

启动三个终端，分别运行上述三个节点：
```shell
ros2 run usb_cam usb_cam_node_exe
ros2 run learning_service service_object_server
ros2 run learning_service service_object_client
```
![](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.5_%E6%9C%8D%E5%8A%A1/image-20220527235144680.png)

![](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.5_%E6%9C%8D%E5%8A%A1/image-20220527235132847.png)

客户端代码解析
learning_service/service_object_client.py
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
@作者: 古月居(www.guyuehome.com)
@说明: ROS2服务示例-请求目标识别，等待目标位置应答
"""

import rclpy                                            # ROS2 Python接口库
from rclpy.node   import Node                           # ROS2 节点类
from learning_interface.srv import GetObjectPosition    # 自定义的服务接口

class objectClient(Node):
    def __init__(self, name):
        super().__init__(name)                          # ROS2节点父类初始化
        self.client = self.create_client(GetObjectPosition, 'get_target_position')
        while not self.client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('service not available, waiting again...')
        self.request = GetObjectPosition.Request()

    def send_request(self):
        self.request.get = True
        self.future = self.client.call_async(self.request)

def main(args=None):
    rclpy.init(args=args)                             # ROS2 Python接口初始化
    node = objectClient("service_object_client")      # 创建ROS2节点对象并进行初始化
    node.send_request()

    while rclpy.ok():
        rclpy.spin_once(node)

        if node.future.done():
            try:
                response = node.future.result()
            except Exception as e:
                node.get_logger().info(
                    'Service call failed %r' % (e,))
            else:
                node.get_logger().info(
                    'Result of object position:\n x: %d y: %d' %
                    (response.x, response.y))
            break
    node.destroy_node()                              # 销毁节点对象
    rclpy.shutdown()                                 # 关闭ROS2 Python接口

```
完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置：
```json
    entry_points={
        'console_scripts': [
         'service_adder_client  = learning_service.service_adder_client:main',
         'service_adder_server  = learning_service.service_adder_server:main',
         'service_object_client = learning_service.service_object_client:main',
        ],
    },

```

服务端代码解析
learning_service/service_object_server.py
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
@作者: 古月居(www.guyuehome.com)
@说明: ROS2服务示例-提供目标识别服务
"""

import rclpy                                           # ROS2 Python接口库
from rclpy.node import Node                            # ROS2 节点类
from sensor_msgs.msg import Image                      # 图像消息类型
import numpy as np                                     # Python数值计算库
from cv_bridge import CvBridge                         # ROS与OpenCV图像转换类
import cv2                                             # Opencv图像处理库
from learning_interface.srv import GetObjectPosition   # 自定义的服务接口

lower_red = np.array([0, 90, 128])     # 红色的HSV阈值下限
upper_red = np.array([180, 255, 255])  # 红色的HSV阈值上限

class ImageSubscriber(Node):
    def __init__(self, name):
        super().__init__(name)                              # ROS2节点父类初始化
        self.sub = self.create_subscription(
            Image, 'image_raw', self.listener_callback, 10) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度）
        self.cv_bridge = CvBridge()                         # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换

        self.srv = self.create_service(GetObjectPosition,   # 创建服务器对象（接口类型、服务名、服务器回调函数）
                                       'get_target_position',
                                       self.object_position_callback)    
        self.objectX = 0
        self.objectY = 0                              

    def object_detect(self, image):
        hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)      # 图像从BGR颜色模型转换为HSV模型
        mask_red = cv2.inRange(hsv_img, lower_red, upper_red) # 图像二值化
        contours, hierarchy = cv2.findContours(
            mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)   # 图像中轮廓检测

        for cnt in contours:                                  # 去除一些轮廓面积太小的噪声
            if cnt.shape[0] < 150:
                continue

            (x, y, w, h) = cv2.boundingRect(cnt)              # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高
            cv2.drawContours(image, [cnt], -1, (0, 255, 0), 2)# 将苹果的轮廓勾勒出来
            cv2.circle(image, (int(x+w/2), int(y+h/2)), 5,
                       (0, 255, 0), -1)                       # 将苹果的图像中心点画出来

            self.objectX = int(x+w/2)
            self.objectY = int(y+h/2)

        cv2.imshow("object", image)                            # 使用OpenCV显示处理后的图像效果
        cv2.waitKey(50)

    def listener_callback(self, data):
        self.get_logger().info('Receiving video frame')        # 输出日志信息，提示已进入回调函数
        image = self.cv_bridge.imgmsg_to_cv2(data, 'bgr8')     # 将ROS的图像消息转化成OpenCV图像
        self.object_detect(image)                              # 苹果检测

    def object_position_callback(self, request, response):     # 创建回调函数，执行收到请求后对数据的处理
        if request.get == True:
            response.x = self.objectX                          # 目标物体的XY坐标
            response.y = self.objectY
            self.get_logger().info('Object position\nx: %d y: %d' %
                                   (response.x, response.y))   # 输出日志信息，提示已经反馈
        else:
            response.x = 0
            response.y = 0
            self.get_logger().info('Invalid command')          # 输出日志信息，提示已经反馈
        return response


def main(args=None):                                 # ROS2节点主入口main函数
    rclpy.init(args=args)                            # ROS2 Python接口初始化
    node = ImageSubscriber("service_object_server")  # 创建ROS2节点对象并进行初始化
    rclpy.spin(node)                                 # 循环等待ROS2退出
    node.destroy_node()                              # 销毁节点对象
    rclpy.shutdown()                                 # 关闭ROS2 Python接口

```
完成代码的编写后需要设置功能包的编译选项，让系统知道Python程序的入口，打开功能包的setup.py文件，加入如下入口点的配置：
```json
    entry_points={
        'console_scripts': [
         'service_adder_client  = learning_service.service_adder_client:main',
         'service_adder_server  = learning_service.service_adder_server:main',
         'service_object_client = learning_service.service_object_client:main',
         'service_object_server = learning_service.service_object_server:main',
        ],
    },

```
#### 服务命令行操作
服务命令的常用操作如下：
```shell
ros2 service list                  # 查看服务列表
ros2 service type <service_name>   # 查看服务数据类型
ros2 service call <service_name> <service_type> <service_data>   # 发送服务请求
```
![](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.5_%E6%9C%8D%E5%8A%A1/image-20220527235949170.png)



